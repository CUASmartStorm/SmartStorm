/////////////////////////////////////////////////////////////
// MAIN.CPP - Application Entry Point
/////////////////////////////////////////////////////////////

#include "smartrainharvest.h"
#include <QApplication>

int main(int argc, char *argv[])
{
    // Initialize the Qt application with command-line arguments
    QApplication a(argc, argv);
    
    // Create the main window instance
    SmartRainHarvest w;
    
    // Display the window in maximized mode
    w.showMaximized();
    
    // Start the Qt event loop and return the exit code when application closes
    return a.exec();
}



/////////////////////////////////////////////////////////////
// CHARTCONTAINER.CPP - Chart Visualization Component
/////////////////////////////////////////////////////////////

#include "chartcontainer.h"

using namespace QtCharts;

// Constructor: Initialize with 10 random colors for chart series
ChartContainer::ChartContainer()
{
    for (int i=0; i<10; i++)
        colors.append(QColor(rand()%256,rand()%256,rand()%256));
}

// Plot a single weather data series on the chart
void ChartContainer::plotWeatherData(const QVector<WeatherData>& weatherData, const QString& yAxisTitle) {
        // Clear existing series and axes from the chart
        chart->removeAllSeries();
        removeAllAxes();
        
        // Create a new line series for the data
        QLineSeries* series = new QLineSeries();
        double max_val = -1e6;
        
        // Add all data points to the series and track maximum value
        for (const auto& data : weatherData) {
            series->append(data.timestamp.toMSecsSinceEpoch(), data.value);
            max_val = std::max(data.value,max_val);
        }

        // Customize the line appearance (width and color)
        QPen pen = series->pen();
        pen.setWidth(4); // Set the desired line thickness
        pen.setColor(colors[0]);
        series->setPen(pen);

        // Add the series to the chart and configure it
        chart->addSeries(series);
        chart->setTitle(yAxisTitle);
        chart->setAnimationOptions(QChart::SeriesAnimations);

        // Configure X-axis (time axis)
        QDateTimeAxis* axisX = new QDateTimeAxis();
        axisX->setTitleText("Time");
        axisX->setFormat("dd/MM HH:mm");
        QFont xAxisFont = axisX->labelsFont();
        xAxisFont.setPointSize(8); // Make font smaller
        axisX->setLabelsFont(xAxisFont);
        axisX->setTickCount(20);
        axisX->setLabelsAngle(90.0); // Rotate labels by 90 degrees
        chart->addAxis(axisX, Qt::AlignBottom);
        series->attachAxis(axisX);

        // Configure Y-axis (value axis)
        QValueAxis* axisY = new QValueAxis();
        axisY->setTitleText(yAxisTitle);
        axisY->setLabelFormat("%.1f");
        QFont yAxisFont = axisY->labelsFont();
        axisY->setRange(0,max_val);
        yAxisFont.setPointSize(8); // Make font smaller
        axisY->setLabelsFont(yAxisFont);
        chart->addAxis(axisY, Qt::AlignLeft);
        series->attachAxis(axisY);

        // Update the chart view with anti-aliasing for smooth rendering
        chartview->setChart(chart);
        chartview->setRenderHint(QPainter::Antialiasing);
}

// Plot multiple weather data series on the same chart (multi-line chart)
void ChartContainer::plotWeatherDataMap(const QMap<QString, QVector<WeatherData>>& weatherDataMap) {
        // Clear existing series and axes
        chart->removeAllSeries();
        removeAllAxes();
        chart->setAnimationOptions(QChart::SeriesAnimations);

        // Find the time range across all series for a unified X-axis
        QDateTime minTime = QDateTime::currentDateTime();
        QDateTime maxTime = QDateTime::fromSecsSinceEpoch(0);

        for (auto it = weatherDataMap.begin(); it != weatherDataMap.end(); ++it) {
            const QVector<WeatherData>& weatherData = it.value();
            if (!weatherData.empty()) {
                QDateTime seriesStartTime = weatherData.front().timestamp;
                QDateTime seriesEndTime = weatherData.back().timestamp;

                if (seriesStartTime < minTime) {
                    minTime = seriesStartTime;
                }
                if (seriesEndTime > maxTime) {
                    maxTime = seriesEndTime;
                }
            }
        }

        // Create and configure the shared X-axis (time)
        QDateTimeAxis* axisX = new QDateTimeAxis();
        axisX->setTitleText("Time");
        axisX->setFormat("dd/MM HH:mm");
        axisX->setTickCount(10);
        QFont xAxisFont = axisX->labelsFont();
        xAxisFont.setPointSize(8); // Make font smaller
        axisX->setLabelsFont(xAxisFont);
        axisX->setLabelsAngle(90.0); // Rotate labels by 90 degrees
        axisX->setRange(minTime,maxTime);
        chart->addAxis(axisX, Qt::AlignBottom);

        // Create a separate series and Y-axis for each data type in the map
        int counter = 0;
        for (auto it = weatherDataMap.begin(); it != weatherDataMap.end(); ++it) {
            counter++;
            const QString& yAxisTitle = it.key();
            const QVector<WeatherData>& weatherData = it.value();

            // Create a line series for this data type
            QLineSeries* series = new QLineSeries();
            series->setName(yAxisTitle);

            // Add all data points to the series
            for (const auto& data : weatherData) {
                series->append(data.timestamp.toMSecsSinceEpoch(), data.value);
            }

            // Customize line appearance with unique color
            QPen pen = series->pen();
            pen.setWidth(4); // Set the desired line thickness
            pen.setColor(colors[counter]);
            series->setPen(pen);

            // Add the series to the chart and attach to X-axis
            chart->addSeries(series);
            series->attachAxis(axisX);

            // Create a dedicated Y-axis for this series
            QValueAxis* axisY = new QValueAxis();
            axisY->setTitleText(yAxisTitle);
            QFont yAxisFont = axisY->labelsFont();
            yAxisFont.setPointSize(8); // Make font smaller
            axisY->setLabelsFont(yAxisFont);
            axisY->setLabelFormat("%.1f");
            chart->addAxis(axisY, Qt::AlignLeft);
            series->attachAxis(axisY);
        }

        // Customize chart title font
        QFont titleFont = chart->titleFont();
        titleFont.setPointSize(10); // Make font smaller
        chart->setTitleFont(titleFont);
        
        // Update chart view with anti-aliasing
        chartview->setChart(chart);
        chartview->setRenderHint(QPainter::Antialiasing);
}

// Helper function to remove all axes from the chart
void ChartContainer::removeAllAxes() {
    // Get a list of all axes associated with the chart
    QList<QAbstractAxis*> axes = chart->axes();

    // Loop through each axis and remove it
    for (QAbstractAxis* axis : axes) {
        chart->removeAxis(axis);
    }
}


/////////////////////////////////////////////////////////////
// CHARTCONTAINER.H - Chart Container Class Header
/////////////////////////////////////////////////////////////

#ifndef CHARTCONTAINER_H
#define CHARTCONTAINER_H
#include <QtCharts/QChartView>
#include <QtCharts/QLineSeries>
#include <QtCharts/QValueAxis>
#include <QtCharts/QDateTimeAxis>
#include <QMap>

#include "noaaweatherfetcher.h"

// Class for managing chart visualization of weather data
class ChartContainer
{
public:
    ChartContainer();
    
    // Plot a single weather data series
    void plotWeatherData(const QVector<WeatherData>& weatherData, const QString& yAxisTitle);
    
    // Plot multiple weather data series on the same chart
    void plotWeatherDataMap(const QMap<QString, QVector<WeatherData>>& weatherDataMap);
    
    // Getter for the chart view widget
    QtCharts::QChartView *GetChartView() {return chartview;}
    
private:
    QtCharts::QChart *chart = new QtCharts::QChart();         // The chart object
    QtCharts::QChartView *chartview = new QtCharts::QChartView();  // Widget to display the chart
    void removeAllAxes();                                      // Helper to clear all axes
    QVector<QColor> colors;                                    // Color palette for series
};

#endif // CHARTCONTAINER_H



/////////////////////////////////////////////////////////////
// DISTANCESENSOR.CPP - Ultrasonic Distance Sensor Control
/////////////////////////////////////////////////////////////

#include "DistanceSensor.h"
#include <cmath>

// Constructor
DistanceSensor::DistanceSensor() {
}

// Destructor - cleanup resources
DistanceSensor::~DistanceSensor() {
    cleanup();
}

// Initialize the distance sensor GPIO pins
bool DistanceSensor::initialize() {
#ifdef RasPi
    wiringPiSetupGpio(); // Use BCM pin numbering
    pinMode(4, OUTPUT);   // Trigger pin
    pinMode(17, INPUT);   // Echo pin
#endif
    return true;
}

// Cleanup function (placeholder for future resource management)
void DistanceSensor::cleanup() {
    // Cleanup resources if needed
}

// Measure distance using ultrasonic sensor
double DistanceSensor::getDistance() {
#ifdef RasPi
    // Clear the TRIG_PIN
    digitalWrite(4, LOW);
    QThread::sleep(2); // Wait for 2 seconds

    // Send a 10 microsecond trigger pulse
    digitalWrite(4, HIGH);
    delayMicroseconds(10);
    digitalWrite(4, LOW);

    // Wait for ECHO_PIN to go HIGH (start of pulse)
    while (digitalRead(17) == LOW);
    long pulseStart = micros();

    // Wait for ECHO_PIN to go LOW (end of pulse)
    while (digitalRead(17) == HIGH);
    long pulseEnd = micros();

    // Calculate the distance based on pulse duration
    // Speed of sound = 343 m/s = 0.0343 cm/μs
    // Distance = (duration / 2) * speed of sound
    double pulseDuration = pulseEnd - pulseStart;
    double distance = pulseDuration * 0.01715; // Distance in cm

    return std::round(distance * 100.0) / 100.0; // Round to 2 decimal places
#endif

    // Return random value for testing when not on Raspberry Pi
    return rand()%100;
}



/////////////////////////////////////////////////////////////
// DISTANCESENSOR.H - Distance Sensor Class Header
/////////////////////////////////////////////////////////////

#ifndef DISTANCESENSOR_H
#define DISTANCESENSOR_H

#include <QObject>
#include <QDebug>
#include <QThread>
#ifdef RasPi
#include <wiringPi.h>
#endif

// Class for managing HC-SR04 ultrasonic distance sensor
class DistanceSensor : public QObject {
    Q_OBJECT

public:
    DistanceSensor();
    ~DistanceSensor();

    bool initialize();      // Setup GPIO pins
    void cleanup();         // Cleanup resources
    double getDistance();   // Get distance measurement in cm

private:
    const int TRIG_PIN = 4;  // BCM pin 4 - Trigger pin
    const int ECHO_PIN = 17; // BCM pin 17 - Echo pin
};

#endif // DISTANCESENSOR_H


/////////////////////////////////////////////////////////////
// NOAAWEATHERFETCHER.CPP - NOAA Weather API Client
/////////////////////////////////////////////////////////////

#include "noaaweatherfetcher.h"
#include <QtNetwork/QNetworkAccessManager>
#include <QtNetwork/QNetworkReply>
#include <QtNetwork/QNetworkRequest>
#include <QJsonDocument>
#include <QEventLoop>
#include <QJsonObject>
#include <QJsonArray>
#include <QDateTime>
#include <vector>
#include <iostream>

// Constructor - initialize network manager
NOAAWeatherFetcher::NOAAWeatherFetcher(QObject* parent) : QObject(parent) {
    manager = new QNetworkAccessManager(this);
}

// Fetch weather prediction data from NOAA API
QVector<WeatherData> NOAAWeatherFetcher::getWeatherPrediction(int latitude, int longitude, datatype type) {
    QVector<WeatherData> weatherData;

    // Construct NOAA API URL for the specified grid coordinates
    QString url;
    url = QString("https://api.weather.gov/gridpoints/LWX/%1,%2").arg(latitude).arg(longitude);
    qDebug()<<url;
    
    // Create HTTP GET request
    QNetworkRequest request((QUrl(url)));
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");

    // Map data type enum to NOAA API field name
    QString DataType;
    switch (type) {
        case datatype::PrecipitationAmount:
            DataType = "quantitativePrecipitation";
            break;
        case datatype::ProbabilityofPrecipitation:
            DataType = "probabilityOfPrecipitation";
            break;
        case datatype::RelativeHumidity:
            DataType = "relativeHumidity";
            break;
        case datatype::Temperature:
            DataType = "temperature";
            break;
    }
    qDebug()<<DataType;
    
    // Send the request
    QNetworkReply* reply = manager->get(request);

    // Wait for the reply to finish (blocking approach for simplicity)
    QEventLoop loop;
    connect(reply, &QNetworkReply::finished, &loop, &QEventLoop::quit);
    loop.exec();

    // Process the response if successful
    if (reply->error() == QNetworkReply::NoError) {
        QByteArray response = reply->readAll();
        QJsonDocument jsonResponse = QJsonDocument::fromJson(response);
        QJsonObject jsonObject = jsonResponse.object();
        QJsonObject properties = jsonObject["properties"].toObject();
        qDebug()<<properties[DataType];
        
        // Extract the time series values array
        QJsonArray periods = properties[DataType].toObject()["values"].toArray();
        qDebug()<<periods;
        
        // Parse each time period's data
        for (const auto& period : periods) {
            QJsonObject obj = period.toObject();

            // Extract timestamp and value
            qDebug()<<obj["validTime"].toString().split("+")[0];
            QDateTime time = QDateTime::fromString(obj["validTime"].toString().split("+")[0], "yyyy-MM-ddTHH:mm:ss");
            qDebug()<<time;
            double value = obj["value"].toDouble();

            weatherData.push_back({time, value});
        }
    } else {
        qWarning() << "Error fetching weather data:" << reply->errorString();
    }

    reply->deleteLater();
    return weatherData;
}

// Calculate cumulative value over a specified number of days
double calculateCumulativeValue(const QVector<WeatherData>& weatherData, int days) {
    if (weatherData.isEmpty()) return 0.0;

    // Define time window
    QDateTime startTime = weatherData.first().timestamp;
    QDateTime endTime = startTime.addDays(days);

    // Sum all values within the time window
    double cumulativeValue = 0.0;
    for (const auto& data : weatherData) {
        if (data.timestamp <= endTime) {
            cumulativeValue += data.value;
        } else {
            break;
        }
    }

    return cumulativeValue;
}



/////////////////////////////////////////////////////////////
// NOAAWEATHERFETCHER.H - Weather Fetcher Class Header
/////////////////////////////////////////////////////////////

#ifndef NOAAWEATHERFETCHER_H
#define NOAAWEATHERFETCHER_H

#include <QtNetwork/QNetworkAccessManager>
#include <QtNetwork/QNetworkReply>
#include <QtNetwork/QNetworkRequest>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QDateTime>
#include <vector>
#include <iostream>

// Enum for different types of weather data
enum class datatype {ProbabilityofPrecipitation, Temperature, PrecipitationAmount, RelativeHumidity};

// Struct to hold weather prediction data point
struct WeatherData {
    QDateTime timestamp;  // Time of the prediction
    double value;         // Value of the measurement
};

class QChartView;

// Class for fetching weather data from NOAA API
class NOAAWeatherFetcher : public QObject {
    Q_OBJECT

public:
    NOAAWeatherFetcher(QObject* parent = nullptr);
    
    // Fetch weather prediction for specified location and data type
    QVector<WeatherData> getWeatherPrediction(int latitude, int longitude, datatype type);

private:
    QNetworkAccessManager* manager;  // Network manager for HTTP requests
};

// Helper function to calculate cumulative values over time
double calculateCumulativeValue(const QVector<WeatherData>& weatherData, int days);

#endif // NOAAWEATHERFETCHER_H


/////////////////////////////////////////////////////////////
// SMARTRAINHARVEST.CPP - Main Application Logic
/////////////////////////////////////////////////////////////

#include "smartrainharvest.h"
#include "ui_smartrainharvest.h"
#include "noaaweatherfetcher.h"
#include "chartcontainer.h"
#include <QMap>
#include <QTimer>
#include <DistanceSensor.h>
#include <QSplitter>
#include <QLabel>
#include <QPushButton>
#include <wiringPi.h>

// Constructor - Initialize the main window and all components
SmartRainHarvest::SmartRainHarvest(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::SmartRainHarvest)
{
    ui->setupUi(this);

    // Location coordinates (Washington DC area)
    //Latitude 38.9072° N
    //Longitude: 77.0369 W

    // Create vertical splitter for main layout
    QSplitter *splitter = new QSplitter(Qt::Vertical, this);

    // Create timer for periodic weather checks
    QTimer *CheckWeatherTimer = new QTimer();

    // Connect timers to their respective slots
    connect(CheckWeatherTimer,SIGNAL(timeout()), this, SLOT(on_Check_Timer()));
    connect(ReleaseTimer,SIGNAL(timeout()), this, SLOT(on_Check_Distance()));

    // Start weather check timer (interval defined in class)
    CheckWeatherTimer->start(Check_Weather_Interval*1000);

    // Setup UI layout with charts
    splitter->addWidget(ProbnQuanChartContainer->GetChartView());
    QSplitter *hsplitter = new QSplitter(Qt::Horizontal, splitter);
    hsplitter->addWidget(CummulativeForcastChartContainer->GetChartView());
    hsplitter->addWidget(WaterDepthChartContainer->GetChartView());
    splitter->addWidget(OpenShutChartContainer->GetChartView());

    // Create control panel with manual valve button and distance display
    QWidget* layoutWidget1 = new QWidget(hsplitter);
    QVBoxLayout *buttonslayout = new QVBoxLayout(layoutWidget1);
    ManualOpenShut = new QPushButton(splitter);
    buttonslayout->addWidget(ManualOpenShut);
    ManualOpenShut->setText("Open Valve");
    DistanceLbl = new QLabel(splitter);
    buttonslayout->addWidget(DistanceLbl);
    connect(ManualOpenShut, SIGNAL(clicked()),this, SLOT(on_ManualOpenShut()) );
    
    // Set stretch factors for splitters (relative sizing)
    splitter->setStretchFactor(0, 1);
    splitter->setStretchFactor(1, 1);
    splitter->setStretchFactor(2, 1);
    hsplitter->setStretchFactor(0, 3);
    hsplitter->setStretchFactor(1, 3);
    hsplitter->setStretchFactor(2, 1);

    // Set the splitter as the central widget
    setCentralWidget(splitter);
    
    // Initialize distance sensor and valve control pin
    distancesensor.initialize();
    pinMode(18, OUTPUT);  // GPIO 18 for valve control
    
    // Run initial weather check
    on_Check_Timer();
}

// Destructor
SmartRainHarvest::~SmartRainHarvest()
{
    delete ui;
}

// Periodic timer callback - Check weather and update system state
void SmartRainHarvest::on_Check_Timer()
{
    qDebug()<<"Checking weather!";
    
    // Container for multiple weather data series
    QMap<QString, QVector<WeatherData>> precip_data;

    // Fetch precipitation amount forecast
    QVector<WeatherData> rainamountdata = fetcher.getWeatherPrediction(latitude, longitude, datatype::PrecipitationAmount);
    precip_data["Precipitation [mm]"] = rainamountdata;

    // Fetch precipitation probability forecast
    QVector<WeatherData> rainprobdata = fetcher.getWeatherPrediction(latitude, longitude, datatype::ProbabilityofPrecipitation);
    precip_data["Precipitation probability (%)"] = rainprobdata;

    // Fetch temperature forecast
    QVector<WeatherData> tempdata = fetcher.getWeatherPrediction(latitude, longitude, datatype::Temperature);
    precip_data["Temperature (<sup>o</sup>C)"] = tempdata;

    // Plot all weather data on the multi-line chart
    ProbnQuanChartContainer->plotWeatherDataMap(precip_data);
    ProbnQuanChartContainer->GetChartView()->setRenderHint(QPainter::Antialiasing);

    // Maintain rolling window of 30 cumulative rain data points
    if (cummulativerain.count()>30) cummulativerain.removeFirst();

    // Calculate and store 2-day cumulative rain forecast
    cummulativerain.append({QDateTime::currentDateTime(),calculateCumulativeValue(rainamountdata,2) });
    CummulativeForcastChartContainer->plotWeatherData(cummulativerain,"Cummulative rain forecast [mm]");

    // Check distance sensor if enabled
    double distance;
    if (checkdistance)
    {   
        distance = distancesensor.getDistance();
        qDebug()<<"Distance = " << distance << " cm";
        DistanceLbl->setText(QString::number(distance));
        
        // Maintain rolling window of 30 depth measurements
        if (depth.count()>30) depth.removeFirst();
        depth.append({QDateTime::currentDateTime(), max_distance - distance});
        WaterDepthChartContainer->plotWeatherData(depth, "Water Depth (cm)");

        // Decision logic: Open valve if depth is high AND rain is forecast
        if (depth.last().value>waterdepthcriteria && cummulativerain.last().value>cummulativeraincriteria)
        {
            overflow = false;
            StartRelease();
        }

        // Decision logic: Open valve if depth exceeds bypass threshold (overflow protection)
        if (depth.last().value>bypassdepthcriteria)
        {
            overflow = true;
            StartRelease();
        }
    }

    // Update valve state chart (maintain rolling window of 100 points)
    if (openshut.count()>100) openshut.removeFirst();
    openshut.append({QDateTime::currentDateTime(), double(int(state))});
    OpenShutChartContainer->plotWeatherData(openshut, "Valve State (on/off)");
    
    // Update manual button text based on current state
    if (!state)
        ManualOpenShut->setText("Open the Valve");
    else
        ManualOpenShut->setText("Shut the Valve");
}

// Start the water release timer
void SmartRainHarvest::StartRelease()
{
    ReleaseTimer->start(10000);  // Check every 10 seconds
}

// Distance check callback during water release
void SmartRainHarvest::on_Check_Distance()
{
    // Measure current water depth
    double distance = distancesensor.getDistance();
    if (depth.count()>30) depth.removeFirst();
    depth.append({QDateTime::currentDateTime(), max_distance - distance});
    WaterDepthChartContainer->plotWeatherData(depth, "Water Depth (cm)");

    // Update valve state chart
    if (openshut.count()>100) openshut.removeFirst();
    openshut.append({QDateTime::currentDateTime(), double(state)});
    OpenShutChartContainer->plotWeatherData(openshut, "Valve State (on/off");

    // Decision logic: Stop release when target depth is reached
    if (depth.last().value<(overflow?depthtoreleaseto:minumumdepth))
    {
        ReleaseTimer->stop();
        ShutTheValve();
        state = false;
    }
    else
    {
        // Continue releasing water
        OpenTheValve();
        state=true;
    }
}

// Open the solenoid valve (GPIO HIGH)
void SmartRainHarvest::OpenTheValve(){
    digitalWrite(18, HIGH);
    qDebug()<<"The valve is now open";
}

// Close the solenoid valve (GPIO LOW)
void SmartRainHarvest::ShutTheValve(){
    digitalWrite(18, LOW);
    qDebug()<<"The valve is now shut";
}

// Manual valve control button callback
void SmartRainHarvest::on_ManualOpenShut()
{
    // Toggle valve state
    if (state)
    {
        ShutTheValve();
        state = false;
    }
    else
    {
        OpenTheValve();
        state = true;
    }
    
    // Update button text
    if (!state)
        ManualOpenShut->setText("Open the Valve");
    else
        ManualOpenShut->setText("Shut the Valve");

    // Update valve state chart
    if (openshut.count()>100) openshut.removeFirst();
    openshut.append({QDateTime::currentDateTime(), double(int(state))});
    OpenShutChartContainer->plotWeatherData(openshut, "Valve State (on/off)");
}



/////////////////////////////////////////////////////////////
// SMARTRAINHARVEST.H - Main Application Class Header
/////////////////////////////////////////////////////////////

#ifndef SMARTRAINHARVEST_H
#define SMARTRAINHARVEST_H

#include <QMainWindow>
#include "noaaweatherfetcher.h"
#include "chartcontainer.h"
#include "DistanceSensor.h"
#include "QTimer"
#include "QPushButton"
#include <QLabel>

QT_BEGIN_NAMESPACE
namespace Ui { class SmartRainHarvest; }
QT_END_NAMESPACE

class QChartView;

// Main application class - Smart rain harvesting system controller
class SmartRainHarvest : public QMainWindow
{
    Q_OBJECT

public:
    SmartRainHarvest(QWidget *parent = nullptr);
    ~SmartRainHarvest();
    
    // Data storage for charts (time series)
    QVector<WeatherData> cummulativerain;  // Cumulative rain forecast
    QVector<WeatherData> depth;            // Water depth measurements
    QVector<WeatherData> openshut;         // Valve state history
    
    // System configuration parameters (adjustable)
    double max_distance = 100;              // Distance to bottom of barrel (cm)
    double waterdepthcriteria = 50;         // Depth threshold for rain-forecast release (cm)
    double cummulativeraincriteria = 50;    // Rain amount to trigger release (mm in 2 days)
    double bypassdepthcriteria = 100;       // Depth threshold for overflow protection (cm)
    double depthtoreleaseto = 75;           // Target depth for overflow release (cm)
    double minumumdepth = 5;                // Target depth for forecast-based release (cm)
    int Check_Weather_Interval = 10;        // Weather check interval (seconds)
    bool checkdistance = false;             // Enable/disable distance sensor
    
    void StartRelease();  // Begin water release process
    
private:
    Ui::SmartRainHarvest *ui;
    NOAAWeatherFetcher fetcher;           // Weather API client
    int latitude = 97;                    // Grid latitude coordinate
    int longitude = 71;                   // Grid longitude coordinate
    
    // Chart containers for visualization
    ChartContainer *ProbnQuanChartContainer = new ChartContainer();          // Weather forecasts
    ChartContainer *CummulativeForcastChartContainer = new ChartContainer(); // Cumulative rain
    ChartContainer *WaterDepthChartContainer = new ChartContainer();         // Water depth
    ChartContainer *OpenShutChartContainer = new ChartContainer();           // Valve state
    
    DistanceSensor distancesensor;        // Ultrasonic sensor interface
    QTimer *ReleaseTimer = new QTimer();  // Timer for water release monitoring
    
    void ShutTheValve();                  // Close valve function
    void OpenTheValve();                  // Open valve function
    
    bool overflow = false;                // Flag: overflow mode active
    bool state = false;                   // Current valve state (open/closed)
    
    // UI controls
    QPushButton *ManualOpenShut;          // Manual valve control button
    QLabel *DistanceLbl;                  // Distance display label
    
public slots:
    void on_Check_Timer();                // Periodic weather check callback
    void on_Check_Distance();             // Periodic distance check during release
    void on_ManualOpenShut();             // Manual valve toggle callback
};

#endif // SMARTRAINHARVEST_H


/////////////////////////////////////////////////////////////